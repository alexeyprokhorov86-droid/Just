"""
Telegram Bot –¥–ª—è –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è —Å–æ–æ–±—â–µ–Ω–∏–π –∏–∑ –≥—Ä—É–ø–ø–æ–≤—ã—Ö —á–∞—Ç–æ–≤.
–ö–∞–∂–¥—ã–π —á–∞—Ç —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç—Å—è –≤ –æ—Ç–¥–µ–ª—å–Ω—É—é —Ç–∞–±–ª–∏—Ü—É.
+ –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –∞–Ω–∞–ª–∏–∑ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π –∏ PDF —á–µ—Ä–µ–∑ Claude Vision

–ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–π –ë–î knowledge_base –Ω–∞ VPS.
"""

import os
import re
import logging
import base64
import tempfile
from datetime import datetime
from telegram import Update
from telegram.ext import Application, MessageHandler, CommandHandler, filters, ContextTypes
import psycopg2
from psycopg2 import sql
from dotenv import load_dotenv
import anthropic

# –ó–∞–≥—Ä—É–∂–∞–µ–º –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è
load_dotenv()

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# ============================================================
# –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø
# ============================================================

BOT_TOKEN = os.getenv("BOT_TOKEN")
ANTHROPIC_API_KEY = os.getenv("ANTHROPIC_API_KEY")

# –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–π –ë–î knowledge_base
DB_HOST = os.getenv("DB_HOST", "localhost")
DB_PORT = os.getenv("DB_PORT", "5432")
DB_NAME = os.getenv("DB_NAME", "knowledge_base")
DB_USER = os.getenv("DB_USER", "knowledge")
DB_PASSWORD = os.getenv("DB_PASSWORD")

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Claude –∫–ª–∏–µ–Ω—Ç–∞
claude_client = None
if ANTHROPIC_API_KEY:
    import httpx
    proxy_url = os.getenv("PROXY_URL")
    if proxy_url:
        http_client = httpx.Client(proxy=proxy_url)
        claude_client = anthropic.Anthropic(api_key=ANTHROPIC_API_KEY, http_client=http_client)
        logger.info(f"Claude Vision –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω —á–µ—Ä–µ–∑ –ø—Ä–æ–∫—Å–∏")
    else:
        claude_client = anthropic.Anthropic(api_key=ANTHROPIC_API_KEY)
        logger.info("Claude Vision –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω")
    logger.info("Claude Vision –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω")
else:
    logger.warning("ANTHROPIC_API_KEY –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω - –∞–Ω–∞–ª–∏–∑ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π –æ—Ç–∫–ª—é—á—ë–Ω")


# ============================================================
# –†–ê–ë–û–¢–ê –° –ë–î
# ============================================================

def get_db_connection():
    """–°–æ–∑–¥–∞—ë—Ç –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ PostgreSQL."""
    return psycopg2.connect(
        host=DB_HOST,
        port=DB_PORT,
        dbname=DB_NAME,
        user=DB_USER,
        password=DB_PASSWORD
    )


def sanitize_table_name(chat_id: int, chat_title: str) -> str:
    """–°–æ–∑–¥–∞—ë—Ç –±–µ–∑–æ–ø–∞—Å–Ω–æ–µ –∏–º—è —Ç–∞–±–ª–∏—Ü—ã –∏–∑ ID –∏ –Ω–∞–∑–≤–∞–Ω–∏—è —á–∞—Ç–∞."""
    translit_map = {
        '–∞': 'a', '–±': 'b', '–≤': 'v', '–≥': 'g', '–¥': 'd', '–µ': 'e', '—ë': 'e',
        '–∂': 'zh', '–∑': 'z', '–∏': 'i', '–π': 'y', '–∫': 'k', '–ª': 'l', '–º': 'm',
        '–Ω': 'n', '–æ': 'o', '–ø': 'p', '—Ä': 'r', '—Å': 's', '—Ç': 't', '—É': 'u',
        '—Ñ': 'f', '—Ö': 'h', '—Ü': 'ts', '—á': 'ch', '—à': 'sh', '—â': 'sch',
        '—ä': '', '—ã': 'y', '—å': '', '—ç': 'e', '—é': 'yu', '—è': 'ya'
    }
    
    title_lower = chat_title.lower()
    transliterated = ''.join(translit_map.get(c, c) for c in title_lower)
    safe_title = re.sub(r'[^a-z0-9]+', '_', transliterated)
    safe_title = re.sub(r'_+', '_', safe_title).strip('_')
    safe_title = safe_title[:30] if safe_title else "unnamed"
    
    return f"tg_chat_{abs(chat_id)}_{safe_title}"


def ensure_table_exists(chat_id: int, chat_title: str) -> str:
    """–°–æ–∑–¥–∞—ë—Ç —Ç–∞–±–ª–∏—Ü—É –¥–ª—è —á–∞—Ç–∞, –µ—Å–ª–∏ –æ–Ω–∞ –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç."""
    table_name = sanitize_table_name(chat_id, chat_title)
    
    conn = get_db_connection()
    try:
        with conn.cursor() as cur:
            cur.execute(sql.SQL("""
                CREATE TABLE IF NOT EXISTS {} (
                    id SERIAL PRIMARY KEY,
                    message_id BIGINT NOT NULL,
                    user_id BIGINT,
                    username VARCHAR(255),
                    first_name VARCHAR(255),
                    last_name VARCHAR(255),
                    message_text TEXT,
                    message_type VARCHAR(50) DEFAULT 'text',
                    reply_to_message_id BIGINT,
                    forward_from_user_id BIGINT,
                    media_file_id TEXT,
                    media_analysis TEXT,
                    timestamp TIMESTAMPTZ NOT NULL,
                    created_at TIMESTAMPTZ DEFAULT NOW(),
                    UNIQUE(message_id)
                )
            """).format(sql.Identifier(table_name)))
            
            cur.execute(sql.SQL("""
                CREATE INDEX IF NOT EXISTS {} ON {} (timestamp)
            """).format(
                sql.Identifier(f"idx_{table_name}_timestamp"),
                sql.Identifier(table_name)
            ))
            
            cur.execute(sql.SQL("""
                CREATE INDEX IF NOT EXISTS {} ON {} (user_id)
            """).format(
                sql.Identifier(f"idx_{table_name}_user_id"),
                sql.Identifier(table_name)
            ))
            
            # –ü–æ–ª–Ω–æ—Ç–µ–∫—Å—Ç–æ–≤—ã–π –ø–æ–∏—Å–∫
            cur.execute(sql.SQL("""
                CREATE INDEX IF NOT EXISTS {} ON {} USING gin(to_tsvector('russian', COALESCE(message_text, '') || ' ' || COALESCE(media_analysis, '')))
            """).format(
                sql.Identifier(f"idx_{table_name}_fts"),
                sql.Identifier(table_name)
            ))
            
            # –¢–∞–±–ª–∏—Ü–∞ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã—Ö
            cur.execute("""
                CREATE TABLE IF NOT EXISTS tg_chats_metadata (
                    chat_id BIGINT PRIMARY KEY,
                    chat_title VARCHAR(255),
                    table_name VARCHAR(100),
                    chat_type VARCHAR(50),
                    added_at TIMESTAMPTZ DEFAULT NOW(),
                    last_message_at TIMESTAMPTZ,
                    total_messages INTEGER DEFAULT 0
                )
            """)
            
            cur.execute("""
                INSERT INTO tg_chats_metadata (chat_id, chat_title, table_name, chat_type, last_message_at)
                VALUES (%s, %s, %s, %s, NOW())
                ON CONFLICT (chat_id) DO UPDATE SET
                    chat_title = EXCLUDED.chat_title,
                    last_message_at = NOW()
            """, (chat_id, chat_title, table_name, "group"))
            
            conn.commit()
            logger.info(f"–¢–∞–±–ª–∏—Ü–∞ {table_name} –≥–æ—Ç–æ–≤–∞ –¥–ª—è —á–∞—Ç–∞ '{chat_title}'")
            
    finally:
        conn.close()
    
    return table_name


def save_message(table_name: str, message_data: dict):
    """–°–æ—Ö—Ä–∞–Ω—è–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ —Ç–∞–±–ª–∏—Ü—É —á–∞—Ç–∞."""
    conn = get_db_connection()
    try:
        with conn.cursor() as cur:
            cur.execute(sql.SQL("""
                INSERT INTO {} (
                    message_id, user_id, username, first_name, last_name,
                    message_text, message_type, reply_to_message_id,
                    forward_from_user_id, media_file_id, media_analysis, timestamp
                ) VALUES (
                    %(message_id)s, %(user_id)s, %(username)s, %(first_name)s, %(last_name)s,
                    %(message_text)s, %(message_type)s, %(reply_to_message_id)s,
                    %(forward_from_user_id)s, %(media_file_id)s, %(media_analysis)s, %(timestamp)s
                )
                ON CONFLICT (message_id) DO UPDATE SET
                    message_text = EXCLUDED.message_text,
                    media_analysis = EXCLUDED.media_analysis
            """).format(sql.Identifier(table_name)), message_data)
            conn.commit()
    finally:
        conn.close()


# ============================================================
# –ê–ù–ê–õ–ò–ó –ò–ó–û–ë–†–ê–ñ–ï–ù–ò–ô –ò PDF
# ============================================================

async def analyze_image_with_claude(image_data: bytes, media_type: str, caption: str = "") -> str:
    """–ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ—Ç –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ —á–µ—Ä–µ–∑ Claude Vision."""
    if not claude_client:
        return ""
    
    try:
        base64_image = base64.standard_b64encode(image_data).decode("utf-8")
        
        prompt = """–ü—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä—É–π —ç—Ç–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏ –æ–ø–∏—à–∏ –µ–≥–æ —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ –Ω–∞ —Ä—É—Å—Å–∫–æ–º —è–∑—ã–∫–µ.

–ï—Å–ª–∏ —ç—Ç–æ –¥–æ–∫—É–º–µ–Ω—Ç (–Ω–∞–∫–ª–∞–¥–Ω–∞—è, —Å—á—ë—Ç, –∞–∫—Ç –∏ —Ç.–¥.):
- –£–∫–∞–∂–∏ —Ç–∏–ø –¥–æ–∫—É–º–µ–Ω—Ç–∞
- –ò–∑–≤–ª–µ–∫–∏ –∫–ª—é—á–µ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ: –Ω–æ–º–µ—Ä, –¥–∞—Ç–∞, –∫–æ–Ω—Ç—Ä–∞–≥–µ–Ω—Ç, —Å—É–º–º—ã, —Ç–æ–≤–∞—Ä—ã/—É—Å–ª—É–≥–∏
- –ö—Ä–∞—Ç–∫–æ –æ–ø–∏—à–∏ —Å—É—Ç—å –¥–æ–∫—É–º–µ–Ω—Ç–∞

–ï—Å–ª–∏ —ç—Ç–æ —Ñ–æ—Ç–æ (—Ç–æ–≤–∞—Ä, –æ–±–æ—Ä—É–¥–æ–≤–∞–Ω–∏–µ, –ª—é–¥–∏, —Ä–∞–±–æ—á–∏–π –ø—Ä–æ—Ü–µ—Å—Å):
- –û–ø–∏—à–∏ —á—Ç–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–æ
- –£–∫–∞–∂–∏ –≤–∞–∂–Ω—ã–µ –¥–µ—Ç–∞–ª–∏ (–∫–æ–ª–∏—á–µ—Å—Ç–≤–æ, —Å–æ—Å—Ç–æ—è–Ω–∏–µ, –æ—Å–æ–±–µ–Ω–Ω–æ—Å—Ç–∏)

–ï—Å–ª–∏ —ç—Ç–æ —Å–∫—Ä–∏–Ω—à–æ—Ç:
- –û–ø–∏—à–∏ —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ —ç–∫—Ä–∞–Ω–∞
- –ò–∑–≤–ª–µ–∫–∏ –≤–∞–∂–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é

–û—Ç–≤–µ—Ç –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –∫—Ä–∞—Ç–∫–∏–º, –∏–Ω—Ñ–æ—Ä–º–∞—Ç–∏–≤–Ω—ã–º –∏ –ø–æ–ª–µ–∑–Ω—ã–º –¥–ª—è –ø–æ–∏—Å–∫–∞."""

        if caption:
            prompt += f"\n\n–ü–æ–¥–ø–∏—Å—å –∫ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—é: {caption}"
        
        response = claude_client.messages.create(
            model="claude-sonnet-4-20250514",
            max_tokens=1000,
            messages=[
                {
                    "role": "user",
                    "content": [
                        {
                            "type": "image",
                            "source": {
                                "type": "base64",
                                "media_type": media_type,
                                "data": base64_image,
                            },
                        },
                        {
                            "type": "text",
                            "text": prompt
                        }
                    ],
                }
            ],
        )
        
        analysis = response.content[0].text
        logger.info(f"–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –ø—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–æ: {len(analysis)} —Å–∏–º–≤–æ–ª–æ–≤")
        return analysis
        
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –∞–Ω–∞–ª–∏–∑–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è: {e}")
        return ""


async def analyze_pdf_with_claude(pdf_data: bytes, filename: str = "") -> str:
    """–ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ—Ç PDF —á–µ—Ä–µ–∑ Claude."""
    if not claude_client:
        return ""
    
    try:
        # –ü—Ä–æ–±—É–µ–º –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å PDF –≤ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
        try:
            from pdf2image import convert_from_bytes
            images = convert_from_bytes(pdf_data, first_page=1, last_page=5)  # –ú–∞–∫—Å–∏–º—É–º 5 —Å—Ç—Ä–∞–Ω–∏—Ü
        except Exception as e:
            logger.warning(f"–ù–µ —É–¥–∞–ª–æ—Å—å –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å PDF –≤ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è: {e}")
            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º PDF –∫–∞–∫ –¥–æ–∫—É–º–µ–Ω—Ç
            base64_pdf = base64.standard_b64encode(pdf_data).decode("utf-8")
            
            response = claude_client.messages.create(
                model="claude-sonnet-4-20250514",
                max_tokens=1500,
                messages=[
                    {
                        "role": "user",
                        "content": [
                            {
                                "type": "document",
                                "source": {
                                    "type": "base64",
                                    "media_type": "application/pdf",
                                    "data": base64_pdf,
                                },
                            },
                            {
                                "type": "text",
                                "text": f"""–ü—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä—É–π —ç—Ç–æ—Ç PDF –¥–æ–∫—É–º–µ–Ω—Ç ({filename}) –∏ –æ–ø–∏—à–∏ –µ–≥–æ —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ –Ω–∞ —Ä—É—Å—Å–∫–æ–º —è–∑—ã–∫–µ.

–£–∫–∞–∂–∏:
- –¢–∏–ø –¥–æ–∫—É–º–µ–Ω—Ç–∞
- –ö–ª—é—á–µ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ (–Ω–æ–º–µ—Ä–∞, –¥–∞—Ç—ã, —Å—É–º–º—ã, –∫–æ–Ω—Ç—Ä–∞–≥–µ–Ω—Ç—ã)
- –ö—Ä–∞—Ç–∫–æ–µ —Å–æ–¥–µ—Ä–∂–∞–Ω–∏–µ

–û—Ç–≤–µ—Ç –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ç–∏–≤–Ω—ã–º –¥–ª—è –ø–æ–∏—Å–∫–∞."""
                            }
                        ],
                    }
                ],
            )
            return response.content[0].text
        
        # –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º –∫–∞–∂–¥—É—é —Å—Ç—Ä–∞–Ω–∏—Ü—É
        all_analysis = []
        for i, image in enumerate(images):
            # –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –≤ bytes
            import io
            img_byte_arr = io.BytesIO()
            image.save(img_byte_arr, format='PNG')
            img_bytes = img_byte_arr.getvalue()
            
            analysis = await analyze_image_with_claude(
                img_bytes, 
                "image/png", 
                f"–°—Ç—Ä–∞–Ω–∏—Ü–∞ {i+1} –¥–æ–∫—É–º–µ–Ω—Ç–∞ {filename}"
            )
            if analysis:
                all_analysis.append(f"[–°—Ç—Ä–∞–Ω–∏—Ü–∞ {i+1}]\n{analysis}")
        
        return "\n\n".join(all_analysis)
        
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –∞–Ω–∞–ª–∏–∑–∞ PDF: {e}")
        return ""


async def download_and_analyze_media(bot, message) -> tuple[str, str]:
    """–°–∫–∞—á–∏–≤–∞–µ—Ç –∏ –∞–Ω–∞–ª–∏–∑–∏—Ä—É–µ—Ç –º–µ–¥–∏–∞—Ñ–∞–π–ª."""
    media_analysis = ""
    media_type_str = "media"
    
    try:
        file = None
        media_type = None
        filename = ""
        
        if message.photo:
            file = await bot.get_file(message.photo[-1].file_id)
            media_type = "image/jpeg"
            media_type_str = "photo"
        elif message.document:
            doc = message.document
            filename = doc.file_name or ""
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç–∏–ø –¥–æ–∫—É–º–µ–Ω—Ç–∞
            if doc.mime_type and doc.mime_type.startswith("image/"):
                file = await bot.get_file(doc.file_id)
                media_type = doc.mime_type
                media_type_str = "image"
            elif doc.mime_type == "application/pdf" or filename.lower().endswith(".pdf"):
                file = await bot.get_file(doc.file_id)
                media_type = "application/pdf"
                media_type_str = "pdf"
            else:
                # –î—Ä—É–≥–∏–µ –¥–æ–∫—É–º–µ–Ω—Ç—ã –ø–æ–∫–∞ –Ω–µ –∞–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º
                media_type_str = "document"
                return media_type_str, ""
        else:
            return media_type_str, ""
        
        if not file:
            return media_type_str, ""
        
        # –°–∫–∞—á–∏–≤–∞–µ–º —Ñ–∞–π–ª
        file_data = await file.download_as_bytearray()
        
        # –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º
        if media_type == "application/pdf":
            media_analysis = await analyze_pdf_with_claude(bytes(file_data), filename)
        elif media_type and media_type.startswith("image/"):
            caption = message.caption or ""
            media_analysis = await analyze_image_with_claude(bytes(file_data), media_type, caption)
        
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –º–µ–¥–∏–∞: {e}")
    
    return media_type_str, media_analysis


# ============================================================
# –û–ü–†–ï–î–ï–õ–ï–ù–ò–ï –¢–ò–ü–ê –°–û–û–ë–©–ï–ù–ò–Ø
# ============================================================

def determine_message_type(message) -> tuple[str, str | None]:
    """–û–ø—Ä–µ–¥–µ–ª—è–µ—Ç —Ç–∏–ø —Å–æ–æ–±—â–µ–Ω–∏—è –∏ file_id –µ—Å–ª–∏ –µ—Å—Ç—å –º–µ–¥–∏–∞."""
    if message.photo:
        return "photo", message.photo[-1].file_id
    elif message.video:
        return "video", message.video.file_id
    elif message.audio:
        return "audio", message.audio.file_id
    elif message.voice:
        return "voice", message.voice.file_id
    elif message.video_note:
        return "video_note", message.video_note.file_id
    elif message.document:
        return "document", message.document.file_id
    elif message.sticker:
        return "sticker", message.sticker.file_id
    elif message.animation:
        return "animation", message.animation.file_id
    elif message.location:
        return "location", None
    elif message.contact:
        return "contact", None
    elif message.poll:
        return "poll", None
    else:
        return "text", None


# ============================================================
# –û–ë–†–ê–ë–û–¢–ß–ò–ö–ò –°–û–û–ë–©–ï–ù–ò–ô
# ============================================================

async def log_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–ª—è –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è –≤—Å–µ—Ö —Å–æ–æ–±—â–µ–Ω–∏–π."""
    message = update.message or update.edited_message
    
    if not message or not message.chat:
        return
    
    # –†–∞–±–æ—Ç–∞–µ–º —Ç–æ–ª—å–∫–æ —Å –≥—Ä—É–ø–ø–æ–≤—ã–º–∏ —á–∞—Ç–∞–º–∏
    if message.chat.type not in ["group", "supergroup"]:
        return
    
    chat_id = message.chat.id
    chat_title = message.chat.title or f"Chat_{abs(chat_id)}"
    
    # –°–æ–∑–¥–∞—ë–º —Ç–∞–±–ª–∏—Ü—É –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
    table_name = ensure_table_exists(chat_id, chat_title)
    
    # –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ç–∏–ø —Å–æ–æ–±—â–µ–Ω–∏—è
    message_type, media_file_id = determine_message_type(message)
    
    # –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º –º–µ–¥–∏–∞ –µ—Å–ª–∏ –µ—Å—Ç—å
    media_analysis = ""
    if message.photo or (message.document and message.document.mime_type):
        analyzed_type, media_analysis = await download_and_analyze_media(context.bot, message)
        if analyzed_type != "media":
            message_type = analyzed_type
        
        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç –∞–Ω–∞–ª–∏–∑–∞ –≤ —á–∞—Ç
        if media_analysis:
            try:
                analysis_preview = media_analysis[:500] + "..." if len(media_analysis) > 500 else media_analysis
                await message.reply_text(
                    f"üìÑ **–ê–Ω–∞–ª–∏–∑ –¥–æ–∫—É–º–µ–Ω—Ç–∞:**\n\n{analysis_preview}",
                    parse_mode="Markdown"
                )
            except Exception as e:
                logger.error(f"–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –∞–Ω–∞–ª–∏–∑–∞: {e}")
    
    # –°–æ–±–∏—Ä–∞–µ–º —Ç–µ–∫—Å—Ç (–≤–∫–ª—é—á–∞—è –ø–æ–¥–ø–∏—Å–∏ –∫ –º–µ–¥–∏–∞)
    text = message.text or message.caption or ""
    
    # –î–∞–Ω–Ω—ã–µ –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è
    message_data = {
        "message_id": message.message_id,
        "user_id": message.from_user.id if message.from_user else None,
        "username": message.from_user.username if message.from_user else None,
        "first_name": message.from_user.first_name if message.from_user else None,
        "last_name": message.from_user.last_name if message.from_user else None,
        "message_text": text,
        "message_type": message_type,
        "reply_to_message_id": message.reply_to_message.message_id if message.reply_to_message else None,
        "forward_from_user_id": None,
        "media_file_id": media_file_id,
        "media_analysis": media_analysis,
        "timestamp": message.date
    }
    
    # –°–æ—Ö—Ä–∞–Ω—è–µ–º
    save_message(table_name, message_data)
    logger.info(f"–°–æ—Ö—Ä–∞–Ω–µ–Ω–æ —Å–æ–æ–±—â–µ–Ω–∏–µ {message.message_id} ({message_type}) –≤ {table_name}")


async def start_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /start."""
    if update.message.chat.type == "private":
        await update.message.reply_text(
            "üëã –ü—Ä–∏–≤–µ—Ç! –Ø –±–æ—Ç –¥–ª—è –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è —Å–æ–æ–±—â–µ–Ω–∏–π.\n\n"
            "üìù –°–æ—Ö—Ä–∞–Ω—è—é –≤—Å–µ —Å–æ–æ–±—â–µ–Ω–∏—è –≤ –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö\n"
            "üñº –ê–Ω–∞–ª–∏–∑–∏—Ä—É—é –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –∏ PDF —á–µ—Ä–µ–∑ AI\n"
            "üîç –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é –ø–æ–∏—Å–∫ –ø–æ –∏—Å—Ç–æ—Ä–∏–∏\n\n"
            "–î–æ–±–∞–≤—å –º–µ–Ω—è –≤ –≥—Ä—É–ø–ø–æ–≤–æ–π —á–∞—Ç!"
        )
    else:
        await update.message.reply_text(
            "‚úÖ –ë–æ—Ç –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω –≤ —ç—Ç–æ–º —á–∞—Ç–µ.\n"
            "üìù –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ —Ç–µ–∫—Å—Ç–∞\n"
            "üñº –ê–Ω–∞–ª–∏–∑ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π –∏ PDF\n"
            "üîç –ü–æ–∏—Å–∫: /search <–∑–∞–ø—Ä–æ—Å>"
        )


async def stats_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–ü–æ–∫–∞–∑—ã–≤–∞–µ—Ç —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –ø–æ —Ç–µ–∫—É—â–µ–º—É —á–∞—Ç—É."""
    message = update.message
    
    if message.chat.type not in ["group", "supergroup"]:
        await message.reply_text("–≠—Ç–∞ –∫–æ–º–∞–Ω–¥–∞ —Ä–∞–±–æ—Ç–∞–µ—Ç —Ç–æ–ª—å–∫–æ –≤ –≥—Ä—É–ø–ø–æ–≤—ã—Ö —á–∞—Ç–∞—Ö.")
        return
    
    chat_id = message.chat.id
    chat_title = message.chat.title or f"Chat_{abs(chat_id)}"
    table_name = sanitize_table_name(chat_id, chat_title)
    
    conn = get_db_connection()
    try:
        with conn.cursor() as cur:
            cur.execute("""
                SELECT EXISTS (
                    SELECT FROM information_schema.tables 
                    WHERE table_name = %s
                )
            """, (table_name,))
            
            if not cur.fetchone()[0]:
                await message.reply_text("üìä –ü–æ–∫–∞ –Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è —ç—Ç–æ–≥–æ —á–∞—Ç–∞.")
                return
            
            # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
            cur.execute(sql.SQL("SELECT COUNT(*) FROM {}").format(sql.Identifier(table_name)))
            total_messages = cur.fetchone()[0]
            
            cur.execute(sql.SQL("SELECT COUNT(DISTINCT user_id) FROM {}").format(sql.Identifier(table_name)))
            unique_users = cur.fetchone()[0]
            
            cur.execute(sql.SQL("""
                SELECT COUNT(*) FROM {} WHERE message_type IN ('photo', 'pdf', 'image')
            """).format(sql.Identifier(table_name)))
            media_count = cur.fetchone()[0]
            
            cur.execute(sql.SQL("""
                SELECT COUNT(*) FROM {} WHERE media_analysis IS NOT NULL AND media_analysis != ''
            """).format(sql.Identifier(table_name)))
            analyzed_count = cur.fetchone()[0]
            
            cur.execute(sql.SQL("""
                SELECT COUNT(*) FROM {} WHERE timestamp::date = CURRENT_DATE
            """).format(sql.Identifier(table_name)))
            today_messages = cur.fetchone()[0]
            
            stats_text = (
                f"üìä *–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —á–∞—Ç–∞*\n\n"
                f"üìù –í—Å–µ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏–π: {total_messages:,}\n"
                f"üë• –£—á–∞—Å—Ç–Ω–∏–∫–æ–≤: {unique_users}\n"
                f"üìÖ –°–µ–≥–æ–¥–Ω—è: {today_messages}\n"
                f"üñº –ú–µ–¥–∏–∞—Ñ–∞–π–ª–æ–≤: {media_count}\n"
                f"ü§ñ –ü—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–æ AI: {analyzed_count}"
            )
            
            await message.reply_text(stats_text, parse_mode="Markdown")
            
    finally:
        conn.close()


async def search_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–ü–æ–∏—Å–∫ –ø–æ —Å–æ–æ–±—â–µ–Ω–∏—è–º –≤ —Ç–µ–∫—É—â–µ–º —á–∞—Ç–µ."""
    message = update.message
    
    if message.chat.type not in ["group", "supergroup"]:
        await message.reply_text("–≠—Ç–∞ –∫–æ–º–∞–Ω–¥–∞ —Ä–∞–±–æ—Ç–∞–µ—Ç —Ç–æ–ª—å–∫–æ –≤ –≥—Ä—É–ø–ø–æ–≤—ã—Ö —á–∞—Ç–∞—Ö.")
        return
    
    query = ' '.join(context.args) if context.args else None
    
    if not query:
        await message.reply_text(
            "üîç –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /search <–∑–∞–ø—Ä–æ—Å>\n\n"
            "–ü—Ä–∏–º–µ—Ä: /search –Ω–∞–∫–ª–∞–¥–Ω–∞—è —Å–∞—Ö–∞—Ä"
        )
        return
    
    chat_id = message.chat.id
    chat_title = message.chat.title or f"Chat_{abs(chat_id)}"
    table_name = sanitize_table_name(chat_id, chat_title)
    
    conn = get_db_connection()
    try:
        with conn.cursor() as cur:
            # –ü–æ–∏—Å–∫ –ø–æ —Ç–µ–∫—Å—Ç—É –∏ –∞–Ω–∞–ª–∏–∑—É –º–µ–¥–∏–∞
            cur.execute(sql.SQL("""
                SELECT 
                    timestamp,
                    COALESCE(first_name, username, '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π') as author,
                    message_type,
                    LEFT(COALESCE(message_text, '') || ' ' || COALESCE(media_analysis, ''), 300) as content
                FROM {}
                WHERE to_tsvector('russian', COALESCE(message_text, '') || ' ' || COALESCE(media_analysis, '')) 
                      @@ plainto_tsquery('russian', %s)
                ORDER BY timestamp DESC
                LIMIT 10
            """).format(sql.Identifier(table_name)), (query,))
            
            results = cur.fetchall()
            
            if not results:
                await message.reply_text(f"üîç –ü–æ –∑–∞–ø—Ä–æ—Å—É ¬´{query}¬ª –Ω–∏—á–µ–≥–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.")
                return
            
            response = f"üîç *–†–µ–∑—É–ª—å—Ç–∞—Ç—ã –ø–æ–∏—Å–∫–∞:* ¬´{query}¬ª\n\n"
            for ts, author, msg_type, content in results:
                date_str = ts.strftime("%d.%m.%Y %H:%M")
                type_emoji = {"photo": "üñº", "pdf": "üìÑ", "document": "üìé"}.get(msg_type, "üí¨")
                content_preview = content[:150] + "..." if len(content) > 150 else content
                response += f"{type_emoji} {date_str} | *{author}*\n{content_preview}\n\n"
            
            await message.reply_text(response, parse_mode="Markdown")
            
    finally:
        conn.close()


async def chats_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–ü–æ–∫–∞–∑—ã–≤–∞–µ—Ç —Å–ø–∏—Å–æ–∫ –≤—Å–µ—Ö –ª–æ–≥–∏—Ä—É–µ–º—ã—Ö —á–∞—Ç–æ–≤."""
    if update.message.chat.type != "private":
        await update.message.reply_text("–≠—Ç–∞ –∫–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –≤ –ª–∏—á–Ω—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏—è—Ö.")
        return
    
    conn = get_db_connection()
    try:
        with conn.cursor() as cur:
            cur.execute("""
                SELECT chat_title, total_messages, last_message_at
                FROM tg_chats_metadata
                ORDER BY last_message_at DESC NULLS LAST
                LIMIT 20
            """)
            chats = cur.fetchall()
            
            if not chats:
                await update.message.reply_text("üì≠ –ü–æ–∫–∞ –Ω–µ—Ç –ø–æ–¥–∫–ª—é—á–µ–Ω–Ω—ã—Ö —á–∞—Ç–æ–≤.")
                return
            
            response = "üìã *–õ–æ–≥–∏—Ä—É–µ–º—ã–µ —á–∞—Ç—ã:*\n\n"
            for title, total, last_msg in chats:
                last_str = last_msg.strftime("%d.%m.%Y %H:%M") if last_msg else "‚Äî"
                total = total or 0
                response += f"‚Ä¢ *{title}*\n  –°–æ–æ–±—â–µ–Ω–∏–π: {total:,} | {last_str}\n\n"
            
            await update.message.reply_text(response, parse_mode="Markdown")
            
    finally:
        conn.close()


# ============================================================
# –ó–ê–ü–£–°–ö
# ============================================================

def main():
    """–ó–∞–ø—É—Å–∫ –±–æ—Ç–∞."""
    if not BOT_TOKEN:
        logger.error("BOT_TOKEN –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –≤ .env!")
        return
    
    if not DB_PASSWORD:
        logger.error("DB_PASSWORD –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –≤ .env!")
        return
    
    # –°–æ–∑–¥–∞—ë–º –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ
    application = Application.builder().token(BOT_TOKEN).build()
    
    # –î–æ–±–∞–≤–ª—è–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –∫–æ–º–∞–Ω–¥
    application.add_handler(CommandHandler("start", start_command))
    application.add_handler(CommandHandler("stats", stats_command))
    application.add_handler(CommandHandler("search", search_command))
    application.add_handler(CommandHandler("chats", chats_command))
    
    # –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–ª—è –≤—Å–µ—Ö —Å–æ–æ–±—â–µ–Ω–∏–π
    application.add_handler(MessageHandler(
        filters.ALL & ~filters.COMMAND,
        log_message
    ))
    
    # –ó–∞–ø—É—Å–∫–∞–µ–º
    logger.info("üöÄ –ë–æ—Ç –∑–∞–ø—É—â–µ–Ω. –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ + –∞–Ω–∞–ª–∏–∑ –º–µ–¥–∏–∞ –∞–∫—Ç–∏–≤–Ω—ã.")
    application.run_polling(allowed_updates=Update.ALL_TYPES)


if __name__ == "__main__":
    main()
